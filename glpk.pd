our $VERSION = '0.01';
pp_setversion($VERSION);
$VERSION = eval $VERSION;

use PDL::Exporter;
use PDL::Types qw(ppdefs_all);

pp_addhdr('
#include <stdlib.h>
#include <math.h>
#include <glpk.h>
#include "glpk_aio.h"

#define CTYPE(p) ("\0FLUDS"[p])
#define SETPARM(sv, key, struc, type, default) { \
		SV **entry = hv_fetch(sv, #key, strlen(#key), 0); \
		struc.key = (entry != NULL && SvOK(*entry)) ? \
			Sv ## type(*entry) : \
			default; \
	}

int glpk (int sense, int n, int m, double *c, int nz, int *rn, int *cn,
      double *a, double *b, char *ctype, int *freeLB, double *lb,
      int *freeUB, double *ub, int *vartype, int isMIP, int lpsolver,
      int save_pb, int scale, const control_params *par,
      double *xmin, double *fmin, int *status,
      double *lambda, double *redcosts, double *time);

');

pp_addpm({At => 'Top'}, <<'EOD');
use strict;
use warnings;

use constant GLP_MIN => 1;	# Octave differs from GLPK!
use constant GLP_MAX => -1;	# Octave differs from GLPK!

use constant GLP_CV => 1;
use constant GLP_IV => 2;
use constant GLP_BV => 3;

use constant GLP_FR => 1;
use constant GLP_LO => 2;
use constant GLP_UP => 3;
use constant GLP_DB => 4;
use constant GLP_FX => 5;

=encoding utf8

=head1 NAME

PDL::Opt::GLPK - PDL interface to the Gnu Linear Programming Kit

=head1 SYNOPSIS

 use PDL::OPT::GLPK;

 $a = pdl('[1 1 1] [10 4 5] [2 2 6]');
 $b = pdl('[100 600 300]');
 $c = pdl('[10 6 4]');
 $lb = zeroes(double, 3);
 $ub = inf(double, 3);
 $ctype = GLP_UP * ones(3);
 $vtype = GLP_CV * ones(3);

 glpk($c, $a, $b $lb, $ub, $ctype, $vtype, GLP_MAX,
	$xopt = null, $fopt = null, $status = null, $lambda = null,
	$redcosts = null, {});

This solves an example from the GLPK documentation:

 Maximize
  obj: + 10 x_1 + 6 x_2 + 4 x_3

 Subject To
  r_1: + x_3 + x_2 + x_1 <= 100
  r_2: + 5 x_3 + 4 x_2 + 10 x_1 <= 600
  r_3: + 6 x_3 + 2 x_2 + 2 x_1 <= 300


=head1 DESCRIPTION

This module provides an interface to GLPK, the Gnu Linear Programming
Kit.
It was ported from Ocatve and mimics the Octave-to-GLPK interface.

=head1 FUNCTIONS

=head2 glpk

 Signature (c(m); a(m, n); b(n); lb(m); ub(m); ctype(n); vtype(m);
	int sense; [o]xopt(m); [o]fopt(); [o]status(); [o]lambda(n);
	[o]redcosts(n); SV *opts)

Parameters: TODO, see Octave doc.

This function cannot broadcast over higher dimensions.

=head1 SEE ALSO

L<https://docs.octave.org/latest/Linear-Programming.html>
L<https://www.gnu.org/software/glpk/>

=cut

EOD

pp_add_exported(qw(GLP_MIN GLP_MAX GLP_CV GLP_IV GLP_BV GLP_FR GLP_LO
	GLP_UP GLP_DB GLP_FX));

pp_bless('PDL::Opt::GLPK');

pp_def('glpk',
	Pars => 'double c(m);
			int rn(nz);
			int cn(nz);
			double a(nz);
			double b(n);
			double lb(m);
			double ub(m);
			int ctype(n);
			int vartype(m);
			int sense();
			byte [t]ctype_c(n);
			int [t]freeLB(m);
			int [t]freeUB(m);
			double [o]xopt(m);
			double [o]fopt();
			int [o]status();
			double [o]lambda(n);
			double [o]redcosts(n);',
	OtherPars => 'SV *param;',
	GenericTypes => ['D'],
	PMCode => q{
		sub PDL::Opt::GLPK::glpk {
			barf("glpk: need 14 arguments") if @_ != 14;
			my $at = $_[1]->xchg(0, 1);
			my $a = pdl(0)->append($at->where($at));
			my $w = $at->whichND;
			my $rn = zeroes($a);
			my $cn = zeroes($a);
			$rn->slice('1:-1') .= $w->slice('(0)') + 1;
			$cn->slice('1:-1') .= $w->slice('(1)') + 1;

			PDL::Opt::GLPK::_glpk_int($_[0], $rn, $cn, $a, @_[2..$#_]);
		}
	},
	Code => q{
			/*
			 * This code was ported from Octave sources in
			 * octave-6.2.0/libinterp/dldfcn/__glpk__.cc
			 */
			int n = $SIZE(n);
			int m = $SIZE(m);
			int nz = $SIZE(nz) - 1;

			loop(m) %{
				$freeLB() = ($lb() == -INFINITY);
			%}

			loop(m) %{
				$freeUB() = ($ub() == INFINITY);
			%}

			loop(n) %{
				$ctype_c() = CTYPE($ctype());
			%}

			int isMIP = 0;
			loop(m) %{
				if ($vartype() > GLP_CV) {
					isMIP = 1;
					break;
				}
			%}
			control_params par;
			struct extra_parms xparm;
			double time;
			int ret;

			if (!SvROK($COMP(param))) {
				croak("'param' is not a reference");
			}
			SV *ref = SvRV($COMP(param));
			if (SvTYPE(ref) != SVt_PVHV) {
				croak("'param' is not a hash reference");
			}
			HV *param = (HV*)ref;

			SETPARM(param, msglev, par, IV, 1);
			if (par.msglev < 0 || par.msglev > 3)
    			croak ("PARAM.msglev must be 0 (no output) or 1 (error and warning messages only [default]) or 2 (normal output) or 3 (full output)");

			SETPARM(param, scale, xparm, IV, 16);
			if (xparm.scale < 0 || xparm.scale > 128)
				croak ("PARAM.scale must either be 128 (automatic selection of scaling options), or a bitwise or of: 1 (geometric mean scaling), 16 (equilibration scaling), 32 (round scale factors to power of two), 64 (skip if problem is well scaled");

			SETPARM(param, dual, par, IV, 1);
			if (par.dual < 1 || par.dual > 3)
				croak("PARAM.dual must be 1 (use two-phase primal simplex [default]) or 2 (use two-phase dual simplex) or 3 (use two-phase dual simplex, and if it fails, switch to the primal simplex)");

			SETPARM(param, price, par, IV, 34);
			if (par.price != 17 && par.price != 34)
				croak("PARAM.price must be 17 (textbook pricing) or 34 (steepest edge pricing [default])");

			SETPARM(param, itlim, par, IV, INT_MAX);
			SETPARM(param, outfrq, par, IV, 200);
			SETPARM(param, branch, par, IV, 4);
			if (par.branch < 1 || par.branch > 5)
				croak("PARAM.branch must be 1 (first fractional variable) or 2 (last fractional variable) or 3 (most fractional variable) or 4 (heuristic by Driebeck and Tomlin [default]) or 5 (hybrid pseudocost heuristic)");

			SETPARM(param, btrack, par, IV, 4);
			if (par.btrack < 1 || par.btrack > 4)
				croak("PARAM.btrack must be 1 (depth first search) or 2 (breadth first search) or 3 (best local bound) or 4 (best projection heuristic [default]");

			SETPARM(param, presol, par, IV, 1);
			if (par.presol < 0 || par.presol > 1)
				croak("PARAM.presol must be 0 (do NOT use LP presolver) or 1 (use LP presolver [default])");

			SETPARM(param, lpsolver, xparm, IV, 1);
			if (xparm.lpsolver < 1 || xparm.lpsolver > 2)
				croak("PARAM.lpsolver must be 1 (simplex method) or 2 (interior point method)");

			SETPARM(param, rtest, par, IV, 34);
			if (par.rtest != 17 && par.rtest != 34)
				croak("PARAM.rtest must be 17 (standard ratio test) or 34 (Harris' two-pass ratio test [default])");

			SETPARM(param, tmlim, par, IV, INT_MAX);
			SETPARM(param, outdly, par, IV, 0);
			SETPARM(param, save_pb, xparm, IV, 0);
			xparm.save_pb = !!xparm.save_pb;

			SETPARM(param, tolbnd, par, NV, 1e-7);
			SETPARM(param, toldj, par, NV, 1e-7);
			SETPARM(param, tolpiv, par, NV, 1e-10);
			SETPARM(param, objll, par, NV, INFINITY);
			SETPARM(param, objul, par, NV, -INFINITY);
			SETPARM(param, tolint, par, NV, 1e-5);
			SETPARM(param, tolobj, par, NV, 1e-7);

			ret = glpk($sense(), m, n, $P(c), nz, $P(rn), $P(cn), $P(a),
				$P(b), $P(ctype_c), $P(freeLB), $P(lb), $P(freeUB),
				$P(ub), $P(vartype), isMIP, xparm.lpsolver,
				xparm.save_pb, xparm.scale, &par, $P(xopt), $P(fopt),
				$P(status), $P(lambda), $P(redcosts), &time);
	},
	Doc => undef
);

pp_done();  # you will need this to finish pp processing
