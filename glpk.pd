our $VERSION = '0.01';
pp_setversion($VERSION);
$VERSION = eval $VERSION;

use PDL::Exporter;
use PDL::Types qw(ppdefs_all);

pp_addhdr('
#include <stdlib.h>
#include <math.h>
#include <glpk.h>
#include "glpk_aio.h"

#define CTYPE(p) ("\0FLUDS"[p])
#define SETPARM(sv, key, struc, type, default) { \
		SV **entry = hv_fetch(sv, #key, strlen(#key), 0); \
		struc.key = (entry != NULL && SvOK(*entry)) ? \
			Sv ## type(*entry) : \
			default; \
	}

int glpk (int sense, int n, int m, double *c, int nz, int *rn, int *cn,
      double *a, double *b, char *ctype, int *freeLB, double *lb,
      int *freeUB, double *ub, int *vartype, int isMIP, int lpsolver,
      int save_pb, int scale, const control_params *par,
      double *xmin, double *fmin, int *status,
      double *lambda, double *redcosts, double *time);

');

pp_addpm({At => 'Top'}, <<'EOD');
use strict;
use warnings;

use constant GLP_MIN => 1;	# Octave differs from GLPK!
use constant GLP_MAX => -1;	# Octave differs from GLPK!

use constant GLP_CV => 1;
use constant GLP_IV => 2;
use constant GLP_BV => 3;

use constant GLP_FR => 1;
use constant GLP_LO => 2;
use constant GLP_UP => 3;
use constant GLP_DB => 4;
use constant GLP_FX => 5;

use constant GLP_MSG_OFF => 0;
use constant GLP_MSG_ERR => 1;
use constant GLP_MSG_ON => 2;
use constant GLP_MSG_ALL => 3;
use constant GLP_MSG_DBG => 4;

use constant GLP_SF_GM => 1;
use constant GLP_SF_EQ => 16;
use constant GLP_SF_2N => 32;
use constant GLP_SF_SKIP => 64;
use constant GLP_SF_AUTO => 128;

use constant GLP_CV => 1;
use constant GLP_IV => 2;
use constant GLP_BV => 3;

use constant GLP_MSG_OFF => 0;
use constant GLP_MSG_ERR => 1;
use constant GLP_MSG_ON => 2;
use constant GLP_MSG_ALL => 3;
use constant GLP_MSG_DBG => 4;

use constant GLP_PRIMAL => 1;
use constant GLP_DUALP => 2;
use constant GLP_DUAL => 3;

use constant GLP_PT_STD => 0x11;
use constant GLP_PT_PSE => 0x22;

use constant GLP_BR_FFV => 1;
use constant GLP_BR_LFV => 2;
use constant GLP_BR_MFV => 3;
use constant GLP_BR_DTH => 4;
use constant GLP_BR_PCH => 5;

use constant GLP_BT_DFS => 1;
use constant GLP_BT_BFS => 2;
use constant GLP_BT_BLB => 3;
use constant GLP_BT_BPH => 4;

use constant GLP_RT_STD => 0x11;
use constant GLP_RT_HAR => 0x22;
use constant GLP_RT_FLIP => 0x33;

use constant GLP_EBADB => 0x01;
use constant GLP_ESING => 0x02;
use constant GLP_ECOND => 0x03;
use constant GLP_EBOUND => 0x04;
use constant GLP_EFAIL => 0x05;
use constant GLP_EOBJLL => 0x06;
use constant GLP_EOBJUL => 0x07;
use constant GLP_EITLIM => 0x08;
use constant GLP_ETMLIM => 0x09;
use constant GLP_ENOPFS => 0x0A;
use constant GLP_ENODFS => 0x0B;
use constant GLP_EROOT => 0x0C;
use constant GLP_ESTOP => 0x0D;
use constant GLP_EMIPGAP => 0x0E;
use constant GLP_ENOFEAS => 0x0F;
use constant GLP_ENOCVG => 0x10;
use constant GLP_EINSTAB => 0x11;
use constant GLP_EDATA => 0x12;
use constant GLP_ERANGE => 0x13;

use constant GLP_UNDEF => 1;
use constant GLP_FEAS => 2;
use constant GLP_INFEAS => 3;
use constant GLP_NOFEAS => 4;
use constant GLP_OPT => 5;
use constant GLP_UNBND => 6;

EOD

pp_add_exported(qw(GLP_MIN GLP_MAX GLP_CV GLP_IV GLP_BV GLP_FR GLP_LO
    GLP_UP GLP_DB GLP_FX GLP_MSG_OFF GLP_MSG_ERR GLP_MSG_ON GLP_MSG_ALL
    GLP_SF_GM GLP_SF_EQ GLP_SF_2N GLP_SF_SKIP GLP_SF_AUTO GLP_CV GLP_IV
    GLP_BV GLP_MSG_OFF GLP_MSG_ERR GLP_MSG_ON GLP_MSG_ALL GLP_MSG_DBG
    GLP_PRIMAL GLP_DUALP GLP_DUAL GLP_PT_STD GLP_PT_PSE GLP_BR_FFV
    GLP_BR_LFV GLP_BR_MFV GLP_BR_DTH GLP_BR_PCH GLP_BT_DFS GLP_BT_BFS
    GLP_BT_BLB GLP_BT_BPH GLP_RT_STD GLP_RT_HAR GLP_RT_FLIP GLP_EBADB
    GLP_ESING GLP_ECOND GLP_EBOUND GLP_EFAIL GLP_EOBJLL GLP_EOBJUL
    GLP_EITLIM GLP_ETMLIM GLP_ENOPFS GLP_ENODFS GLP_EROOT GLP_ESTOP
    GLP_EMIPGAP GLP_ENOFEAS GLP_ENOCVG GLP_EINSTAB GLP_EDATA GLP_ERANGE
    GLP_UNDEF GLP_FEAS GLP_INFEAS GLP_NOFEAS GLP_OPT GLP_UNBND));

pp_bless('PDL::Opt::GLPK');

pp_def('glpk',
	Pars => 'double c(m);
			int rn(nz);
			int cn(nz);
			double a(nz);
			double b(n);
			double lb(m);
			double ub(m);
			int ctype(n);
			int vartype(m);
			int sense();
			byte [t]ctype_c(n);
			int [t]freeLB(m);
			int [t]freeUB(m);
			double [o]xopt(m);
			double [o]fopt();
			int [o]errnum();
			int [o]status();
			double [o]lambda(n);
			double [o]redcosts(n);',
	OtherPars => 'SV *param;',
	GenericTypes => ['D'],
	PMCode => q{
		sub PDL::Opt::GLPK::glpk {
			barf("glpk: need 15 arguments") if @_ != 15;
			my $at = $_[1]->xchg(0, 1);
			my $a = pdl(0)->append($at->isa('PDL::CCS::Nd') ?
				$at->[$PDL::CCS::Nd::VALS]->slice('0:-2') :
				$at->where($at));
			my $nnz = $a->nelem;
			my $w = $at->whichND;
			my $rn = zeroes($nnz);
			my $cn = zeroes($nnz);
			$rn->slice('1:-1') .= $w->slice('(0)') + 1;
			$cn->slice('1:-1') .= $w->slice('(1)') + 1;

			PDL::Opt::GLPK::_glpk_int($_[0], $rn, $cn, $a, @_[2..$#_]);
		}
	},
	Code => q{
			/*
			 * This code was ported from Octave sources in
			 * libinterp/dldfcn/__glpk__.cc
			 */
			int n = $SIZE(n);
			int m = $SIZE(m);
			int nz = $SIZE(nz) - 1;

			int isMIP = 0;
			loop(m) %{
				$freeLB() = ($lb() == -INFINITY);
				$freeUB() = ($ub() == INFINITY);
				if ($vartype() > GLP_CV) {
					isMIP = 1;
				}
			%}

			loop(n) %{
				$ctype_c() = CTYPE($ctype());
			%}

			control_params par;
			struct extra_parms xparm;
			double time;
			int ret;

			if (!SvROK($COMP(param))) {
				$CROAK("'param' is not a reference");
			}
			SV *ref = SvRV($COMP(param));
			if (SvTYPE(ref) != SVt_PVHV) {
				$CROAK("'param' is not a hash reference");
			}
			HV *param = (HV*)ref;

			SETPARM(param, msglev, par, IV, 1);
			if (par.msglev < 0 || par.msglev > 4)
    			$CROAK("PARAM.msglev must be 0 (no output) or 1 (error and warning messages only [default]) or 2 (normal output) or 3 (full output)");

			SETPARM(param, scale, xparm, IV, 16);
			if (xparm.scale < 0 || xparm.scale > 128)
				$CROAK("PARAM.scale must either be 128 (automatic selection of scaling options), or a bitwise or of: 1 (geometric mean scaling), 16 (equilibration scaling), 32 (round scale factors to power of two), 64 (skip if problem is well scaled");

			SETPARM(param, dual, par, IV, 1);
			if (par.dual < 1 || par.dual > 3)
				$CROAK("PARAM.dual must be 1 (use two-phase primal simplex [default]) or 2 (use two-phase dual simplex) or 3 (use two-phase dual simplex, and if it fails, switch to the primal simplex)");

			SETPARM(param, price, par, IV, 34);
			if (par.price != 17 && par.price != 34)
				$CROAK("PARAM.price must be 17 (textbook pricing) or 34 (steepest edge pricing [default])");

			SETPARM(param, itlim, par, IV, INT_MAX);
			SETPARM(param, outfrq, par, IV, 200);
			SETPARM(param, branch, par, IV, 4);
			if (par.branch < 1 || par.branch > 5)
				$CROAK("PARAM.branch must be 1 (first fractional variable) or 2 (last fractional variable) or 3 (most fractional variable) or 4 (heuristic by Driebeck and Tomlin [default]) or 5 (hybrid pseudocost heuristic)");

			SETPARM(param, btrack, par, IV, 4);
			if (par.btrack < 1 || par.btrack > 4)
				$CROAK("PARAM.btrack must be 1 (depth first search) or 2 (breadth first search) or 3 (best local bound) or 4 (best projection heuristic [default]");

			SETPARM(param, presol, par, IV, 1);
			if (par.presol < 0 || par.presol > 1)
				$CROAK("PARAM.presol must be 0 (do NOT use LP presolver) or 1 (use LP presolver [default])");

			SETPARM(param, lpsolver, xparm, IV, 1);
			if (xparm.lpsolver < 1 || xparm.lpsolver > 2)
				$CROAK("PARAM.lpsolver must be 1 (simplex method) or 2 (interior point method)");

			SETPARM(param, rtest, par, IV, 34);
			if (par.rtest != 17 && par.rtest != 34)
				$CROAK("PARAM.rtest must be 17 (standard ratio test) or 34 (Harris' two-pass ratio test [default])");

			SETPARM(param, tmlim, par, IV, INT_MAX);
			SETPARM(param, outdly, par, IV, 0);
			SETPARM(param, save_pb, xparm, IV, 0);
			xparm.save_pb = !!xparm.save_pb;

			SETPARM(param, tolbnd, par, NV, 1e-7);
			SETPARM(param, toldj, par, NV, 1e-7);
			SETPARM(param, tolpiv, par, NV, 1e-10);
			SETPARM(param, objll, par, NV, INFINITY);
			SETPARM(param, objul, par, NV, -INFINITY);
			SETPARM(param, tolint, par, NV, 1e-5);
			SETPARM(param, tolobj, par, NV, 1e-7);

			$errnum() = glpk($sense(), m, n, $P(c), nz, $P(rn), $P(cn),
                $P(a), $P(b), $P(ctype_c), $P(freeLB), $P(lb), $P(freeUB),
				$P(ub), $P(vartype), isMIP, xparm.lpsolver,
				xparm.save_pb, xparm.scale, &par, $P(xopt), $P(fopt),
				$P(status), $P(lambda), $P(redcosts), &time);

	},
	Doc => undef
);

pp_done();  # you will need this to finish pp processing

__DATA__
=head1 NAME

PDL::Opt::GLPK - PDL interface to the GNU Linear Programming Kit
